---
description: 
globs: 
alwaysApply: false
---
# Guide for Porting Features from Landing to Desktop App

## Architecture Overview
- `/landing` - Next.js web application with feature implementations
- `/desktop` - Electron desktop application, target for new features
- `/shared` - Common utilities used by both applications

## Implementation Flow

1. **Identify the Landing Page Implementation**
   - Source feature components are in: `/landing/app/tools/{feature-name}/`
   - Example: Base64 Encoder at `/landing/app/tools/base64-codec/Base64Codec.tsx`
   - Example: JSON Formatter at `/landing/app/tools/json-formatter/JsonFormatter.tsx`

2. **Locate Shared Logic**
   - Core business logic should be in: `/shared/src/{feature-name}/`
   - Example: Base64 functions at `/shared/src/base64-codec/index.ts`
   - Example: JSON utilities at `/shared/src/json-formatter/index.ts`
   - Import in desktop using: `import { ... } from 'shared/{feature-name}'`

3. **Create Desktop Component**
   - Target path: `/desktop/src/components/{feature-name}.tsx`
   - Use desktop UI components from: `/desktop/src/components/ui/`
   - Follow existing patterns like in `/desktop/src/components/json-formatter.tsx`
   - Adapt Next.js components to match desktop styling

4. **Update Desktop App**
   - Add to tools list in `/desktop/src/App.tsx`:
     ```tsx
     const tools: Tool[] = [
       // ... existing tools
       { id: '{feature-id}', name: '{Feature Name}', icon: <IconComponent size={16} /> },
     ]
     ```
   - Add conditional rendering in the same file:
     ```tsx
     {selectedTool === '{feature-id}' ? (
       <YourComponent className="min-h-full" />
     ) : (
       // ... existing code
     )}
     ```

5. **Testing Requirements**
      - Create a test file for each feature at `/desktop/test/{feature-name}.spec.ts`
      - Use shared test utilities from `/desktop/test/utils.ts`:
        ```tsx
        import { launchElectronWithRetry, findButtonByText, takeScreenshot } from './utils';
        ```
      - Use explicit waiting for elements instead of timeouts:
        ```tsx
        // Wait for component to be visible
        await page.waitForSelector('h3:has-text("Feature Name")', { 
          state: 'visible',
          timeout: isCI ? 5000 : 1500 
        });
        ```
      - Wait for content changes with waitForFunction:
        ```tsx
        // Wait for output to appear
        await page.waitForFunction(() => {
          const textareas = document.querySelectorAll('textarea');
          return textareas.length > 1 && textareas[1].value !== '';
        }, { timeout: 2000 });
        ```
      - Take screenshots at each step for better debugging:
        ```tsx
        await takeScreenshot(page, 'feature-name', 'step-description');
        ```
      - Find buttons by text content instead of selectors:
        ```tsx
        await (await findButtonByText(page, 'Button Text')).click();
        ```
      - Verify component content with assertions:
        ```tsx
        await expect(page.$eval('h3', el => el.textContent)).resolves.toBe('Expected Title');
        ```
      - Run tests with: `pnpm run test`
      - Tests should verify that:
        - The component renders correctly
        - User interactions (click, input) work as expected
        - The component produces correct output
        - Error states are handled properly