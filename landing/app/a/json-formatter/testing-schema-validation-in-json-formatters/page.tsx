import type { Metadata } from "next";
import { Check, X, AlertTriangle, Code, FileJson, TestTube, FlaskConical } from 'lucide-react'; // Using available icons

export const metadata: Metadata = {
  title: "Testing Schema Validation in JSON Formatters | Offline Tools",
  description:
    "A guide for developers on how to effectively test schema validation for JSON outputs generated by formatters.",
};

// No 'use client'
// No useState
// No props
export default function TestingSchemaValidationArticle() {
  return (
    <div className="container mx-auto px-4 py-8 prose dark:prose-invert max-w-3xl">
      {/* Increased padding and limited width for readability */}
      <h1 className="text-3xl font-bold mb-6 flex items-center gap-3">
        <FlaskConical className="w-8 h-8 text-blue-500" />
        Testing Schema Validation in JSON Formatters
      </h1>

      <section className="space-y-6">
        <p>
          In the world of data exchange, JSON is ubiquitous. Whether you're building APIs, configuring applications,
          or storing data, chances are you're interacting with JSON. Often, applications need to take raw data and
          <strong>format</strong> it into a specific JSON structure before sending it out or saving it.
        </p>
        <p>
          While your formatter logic might seem straightforward, ensuring the output JSON strictly adheres to a defined
          structure (a <strong>schema</strong>) is crucial for reliability and interoperability. This is where
          <strong>testing schema validation</strong> becomes essential.
        </p>

        <h2 className="text-2xl font-semibold mt-8 mb-4 flex items-center gap-2">
          <Code className="w-6 h-6 text-green-500" />
          What is Schema Validation?
        </h2>
        <p>
          Think of a schema as a contract for your data. It defines the expected structure, data types, required fields,
          allowed values, and relationships within a JSON document.
        </p>
        <p>
          <strong>JSON Schema</strong> is a popular standard for describing the structure of JSON data. It allows you
          to specify constraints like:
        </p>
        <ul className="list-disc pl-6 space-y-2 my-4">
          <li>What properties an object should have.</li>
          <li>The data type of each property (string, number, boolean, array, object, null).</li>
          <li>Whether a property is required or optional.</li>
          <li>Minimum/maximum values for numbers or strings.</li>
          <li>Patterns (regex) for string values.</li>
          <li>Items allowed in an array.</li>
          <li>Relationships between properties.</li>
        </ul>
        <p>
          <strong>Schema validation</strong> is the process of checking whether a given JSON document conforms to its defined schema. If it doesn&apos;t, the validation process should report specific errors indicating what went wrong.
        </p>

        <h2 className="text-2xl font-semibold mt-8 mb-4 flex items-center gap-2">
          <AlertTriangle className="w-6 h-6 text-yellow-500" />
          Why Test Schema Validation?
        </h2>
        <p>
          You might wonder, &quot;If my formatter builds the JSON according to the rules, why do I need to validate it?&quot;
          Here&apos;s why it&apos;s critical:
        </p>
        <ul className="list-disc pl-6 space-y-2 my-4">
          <li>
            <strong>Preventing Bugs:</strong> Formatters can have bugs. A simple logic error might output a number instead of a string, miss a required field, or use the wrong key name.
          </li>
          <li>
            <strong>Ensuring API Contracts:</strong> If your JSON is an API response, the schema is your contract with consumers. Broken contracts lead to broken integrations for others.
          </li>
          <li>
            <strong>Maintaining Data Integrity:</strong> When storing or processing JSON internally, validating against a schema ensures consistency and prevents invalid data from corrupting downstream processes.
          </li>
          <li>
            <strong>Refactoring Confidence:</strong> When you refactor your formatter code, tests that validate the output schema give you confidence that you haven&apos;t inadvertently changed the output structure.
          </li>
          <li>
            <strong>Clear Error Reporting:</strong> Validation libraries provide specific error messages, making debugging failed formatting attempts much easier.
          </li>
        </ul>
        <p>
          Testing this validation step acts as a safety net, catching issues early in the development cycle.
        </p>

        <h2 className="text-2xl font-semibold mt-8 mb-4 flex items-center gap-2">
          <FileJson className="w-6 h-6 text-purple-500" />
          How to Validate and Test Validation
        </h2>
        <p>
          Validation is typically done using a dedicated JSON Schema validation library. These libraries take a JSON Schema definition and a JSON data object and return a boolean indicating validity, plus a list of validation errors if it&apos;s invalid.
        </p>
        <p>
          Popular libraries exist for most programming languages (e.g., AJV for JavaScript/TypeScript, jsonschema for Python, etc.). The core idea is the same:
        </p>
        <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4">
          <h3 className="text-lg font-medium mb-2">Conceptual Validation Process:</h3>
          <pre className="bg-white p-3 rounded dark:bg-gray-900 overflow-x-auto text-sm">
            {`1. Define your JSON Schema (as a JavaScript object or JSON file).
2. Get the JSON data output from your formatter.
3. Use a validation library to compile the schema.
4. Use the compiled schema validator function to check the data.
5. If validation fails, inspect the errors provided by the library.`}
          </pre>
        </div>

        <h2 className="text-2xl font-semibold mt-8 mb-4 flex items-center gap-2">
          <TestTube className="w-6 h-6 text-cyan-500" />
          Example: Data, Schema, and Validation
        </h2>
        <p>Let&apos;s consider a simple example:</p>

        <h3 className="text-xl font-semibold mt-6 mb-2">Sample JSON Data (Expected Output):</h3>
        <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4">
          <pre className="bg-white p-3 rounded dark:bg-gray-900 overflow-x-auto text-sm">
            {`{
  "id": "user-123",
  "name": "Alice Smith",
  "age": 30,
  "isActive": true,
  "tags": ["employee", "marketing"]
}`}
          </pre>
        </div>

        <h3 className="text-xl font-semibold mt-6 mb-2">Corresponding JSON Schema:</h3>
        <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4">
          <pre className="bg-white p-3 rounded dark:bg-gray-900 overflow-x-auto text-sm">
            {`{
  "type": "object",
  "properties": {
    "id": { "type": "string" },
    "name": { "type": "string" },
    "age": { "type": "integer", "minimum": 0 },
    "isActive": { "type": "boolean" },
    "tags": {
      "type": "array",
      "items": { "type": "string" }
    }
  },
  "required": ["id", "name", "age", "isActive"]
}`}
          </pre>
        </div>

        <h3 className="text-xl font-semibold mt-6 mb-2">Conceptual Validation Code (using &apos;ajv&apos;):</h3>
        <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4">
           <pre className="bg-white p-3 rounded dark:bg-gray-900 overflow-x-auto text-sm">
            {`// Assuming 'ajv' is installed and imported
// import Ajv from 'ajv';

const userSchema = {
  type: "object",
  properties: {
    id: { type: "string" },
    name: { type: "string" },
    age: { type: "integer", minimum: 0 },
    isActive: { type: "boolean" },
    tags: {
      type: "array",
      items: { type: "string" }
    }
  },
  required: ["id", "name", "age", "isActive"]
};

// This function represents your formatter
function formatUserData(rawData: any): any {
  // ... your formatting logic here ...
  // This is a placeholder returning valid data
  return {
    id: rawData.userId || null, // Example: rawData might be different
    name: rawData.userName,
    age: rawData.userAge,
    isActive: rawData.userStatus === 'active',
    tags: rawData.userTags ? rawData.userTags.split(',') : []
  };
}

// Assume raw input data
const inputData = {
  userId: "user-123",
  userName: "Alice Smith",
  userAge: 30,
  userStatus: 'active',
  userTags: 'employee,marketing'
};

const formattedData = formatUserData(inputData);

// --- Validation Step ---
// const ajv = new Ajv(); // In a real test, you'd typically create this once
// const validate = ajv.compile(userSchema); // Compile schema

// const isValid = validate(formattedData);

// if (!isValid) {
//   console.error("Validation Errors:", validate.errors);
//   // In a test, you would assert that errors exist or have specific details
// } else {
//   console.log("Data is valid!");
//   // In a test, you would assert that isValid is true
// }

// Note: The actual validation logic would live in your test file,
// not within the formatter itself.`}
          </pre>
        </div>

        <h2 className="text-2xl font-semibold mt-8 mb-4 flex items-center gap-2">
          <TestTube className="w-6 h-6 text-cyan-500" />
          Testing the Validation Process Itself
        </h2>
        <p>
          Your tests should cover two main areas:
        </p>
        <ol className="list-decimal pl-6 space-y-2 my-4">
          <li>
            <strong>Testing the Validator Setup:</strong> Ensure your schema is correctly defined and the validation library is configured to validate against it. This is often implicitly tested when you test your formatter, but dedicated tests for complex schemas can be useful.
          </li>
          <li>
            <strong>Testing the Formatter&apos;s Output:</strong> This is the primary goal. You pass various inputs to your formatter and then validate its output against the schema.
          </li>
        </ol>

        <h3 className="text-xl font-semibold mt-6 mb-2">Types of Tests for Formatter Output:</h3>

        <h4 className="text-lg font-semibold mt-4 mb-2 flex items-center gap-2">
          <Check className="w-5 h-5 text-green-500" />
          1. Valid Data Tests
        </h4>
        <p>
          Test cases where the input data should result in a perfectly valid JSON output according to the schema.
        </p>
        <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4">
           <pre className="bg-white p-3 rounded dark:bg-gray-900 overflow-x-auto text-sm">
            {`// Test case: Standard valid input
test('formatter outputs valid JSON for standard data', () => {
  const input = { userId: "user-123", userName: "Alice", userAge: 30, userStatus: 'active', userTags: 'dev' };
  const output = formatUserData(input); // Call your formatter
  const isValid = validate(output);      // Use your compiled validator

  expect(isValid).toBe(true);
  expect(validate.errors).toBeNull(); // Or expect(validate.errors).toBeUndefined() depending on library
});

// Test case: Valid input with optional fields missing (if applicable)
test('formatter outputs valid JSON when optional fields are missing', () => {
  const input = { userId: "user-456", userName: "Bob", userAge: 25, userStatus: 'inactive' /* no userTags */ };
  const output = formatUserData(input);
  const isValid = validate(output);

  expect(isValid).toBe(true);
  expect(validate.errors).toBeNull();
});`}
          </pre>
        </div>

        <h4 className="text-lg font-semibold mt-4 mb-2 flex items-center gap-2">
           <X className="w-5 h-5 text-red-500" />
          2. Invalid Data Tests
        </h4>
        <p>
          These are crucial. Test cases where the input data should cause the formatter to produce output that
          violates the schema. The test should assert that validation fails and, ideally, check for specific error details.
        </p>
        <ul className="list-disc pl-6 space-y-2 my-4">
          <li>
            <strong>Missing Required Fields:</strong> What happens if the input data lacks information needed for a required field in the output?
            <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4">
               <pre className="bg-white p-3 rounded dark:bg-gray-900 overflow-x-auto text-sm">
                {`// Test case: Missing required field 'name' in output
test('formatter outputs invalid JSON when input is missing user name', () => {
  const input = { userId: "user-789", userAge: 40, userStatus: 'active' }; // Missing userName
  const output = formatUserData(input); // Assumes formatUserData handles missing input gracefully, maybe returns undefined or null for name

  const isValid = validate(output);

  expect(isValid).toBe(false);
  // Expecting a specific error related to the 'name' property missing or being null/undefined
  expect(validate.errors).toEqual(
    expect.arrayContaining([
      expect.objectContaining({
        keyword: 'type', // Or 'required', depends on how AJV reports this
        dataPath: '.name',
        message: 'must be string' // Or 'must have required property 'name''
      })
    ])
  );
});`}
              </pre>
            </div>
          </li>
          <li>
            <strong>Wrong Data Types:</strong> Test inputs that should cause the formatter to output a field with the wrong type.
            <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4">
               <pre className="bg-white p-3 rounded dark:bg-gray-900 overflow-x-auto text-sm">
                {`// Test case: Outputting wrong type for 'age'
test('formatter outputs invalid JSON with wrong type for age', () => {
  const input = { userId: "user-101", userName: "Charlie", userAge: "thirty", userStatus: 'active' }; // Age is a string
  const output = formatUserData(input); // Assumes formatUserData might pass this string through or handle it poorly

  const isValid = validate(output);

  expect(isValid).toBe(false);
  expect(validate.errors).toEqual(
    expect.arrayContaining([
      expect.objectContaining({
        keyword: 'type',
        dataPath: '.age',
        message: 'must be integer'
      })
    ])
  );
});`}
              </pre>
            </div>
          </li>
          <li>
            <strong>Incorrect Format/Constraints:</strong> Test number ranges, string patterns, array item types, etc.
            <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4">
               <pre className="bg-white p-3 rounded dark:bg-gray-900 overflow-x-auto text-sm">
                {`// Test case: Outputting age less than minimum (0)
test('formatter outputs invalid JSON with age less than minimum', () => {
  const input = { userId: "user-112", userName: "Diana", userAge: -5, userStatus: 'active' }; // Age is negative
  const output = formatUserData(input);

  const isValid = validate(output);

  expect(isValid).toBe(false);
  expect(validate.errors).toEqual(
    expect.arrayContaining([
      expect.objectContaining({
        keyword: 'minimum',
        dataPath: '.age',
        message: 'must be >= 0'
      })
    ])
  );
});`}
              </pre>
            </div>
          </li>
          <li>
            <strong>Extra/Unexpected Properties:</strong> If your schema uses <code>&quot;additionalProperties&quot;: false</code>, test that extra fields in the output cause validation failure.
             <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4">
               <pre className="bg-white p-3 rounded dark:bg-gray-900 overflow-x-auto text-sm">
                {`// Assume schema had "additionalProperties": false
// Test case: Formatter adds an unexpected property
test('formatter outputs invalid JSON with unexpected property', () => {
  // Assume formatUserData accidentally adds { extraField: 'oops' }
  const input = { userId: "user-131", userName: "Eve", userAge: 28, userStatus: 'active' };
  const output = { ...formatUserData(input), extraField: 'oops' }; // Simulate formatter error

  const isValid = validate(output);

  expect(isValid).toBe(false);
  expect(validate.errors).toEqual(
    expect.arrayContaining([
      expect.objectContaining({
        keyword: 'additionalProperties',
        dataPath: '', // Often empty for additionalProperties
        params: { additionalProperty: 'extraField' },
        message: 'must NOT have additional properties'
      })
    ])
  );
});`}
              </pre>
            </div>
          </li>
        </ul>

        <h4 className="text-lg font-semibold mt-4 mb-2 flex items-center gap-2">
           <AlertTriangle className="w-5 h-5 text-orange-500" />
          3. Edge Cases
        </h4>
        <p>
          Consider inputs that might lead to edge cases in your formatter&apos;s output:
        </p>
        <ul className="list-disc pl-6 space-y-2 my-4">
          <li>Empty input data for the formatter.</li>
          <li>Inputs that should result in empty objects or arrays in the output.</li>
          <li>Inputs that should result in <code>null</code> values (if allowed by schema).</li>
          <li>Arrays with empty items or wrong item types (if schema specifies item type).</li>
        </ul>

        <h2 className="text-2xl font-semibold mt-8 mb-4 flex items-center gap-2">
          <Check className="w-6 h-6 text-green-500" />
          Structuring Your Tests
        </h2>
        <p>
          Organize your tests logically. A common pattern is to group tests by the formatter function
          or the schema they validate against.
        </p>
        <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4">
           <pre className="bg-white p-3 rounded dark:bg-gray-900 overflow-x-auto text-sm">
            {`// Example test file structure (using Jest or similar)
// import { formatUserData } from './userFormatter'; // Your formatter
// import { userSchema } from './userSchema';         // Your schema
// import Ajv from 'ajv';

// const ajv = new Ajv();
// const validateUser = ajv.compile(userSchema);

describe('User Data Formatter Output Validation', () => {

  // Test suite for valid outputs
  describe('Valid Outputs', () => {
    test('should produce valid JSON for complete input', () => {
      const input = { userId: "u1", userName: "Test User", userAge: 25, userStatus: 'active', userTags: 'a,b' };
      const output = formatUserData(input);
      expect(validateUser(output)).toBe(true);
      expect(validateUser.errors).toBeNull();
    });

    test('should produce valid JSON for input with no tags', () => {
      const input = { userId: "u2", userName: "Another User", userAge: 40, userStatus: 'inactive' };
      const output = formatUserData(input);
      expect(validateUser(output)).toBe(true);
      expect(validateUser.errors).toBeNull();
    });

    // Add more valid cases...
  });

  // Test suite for invalid outputs
  describe('Invalid Outputs', () => {
    test('should fail validation when name is missing', () => {
      const input = { userId: "u3", userAge: 35, userStatus: 'active' }; // Missing userName
      const output = formatUserData(input);
      expect(validateUser(output)).toBe(false);
      expect(validateUser.errors).toEqual(
         expect.arrayContaining([ expect.objectContaining({ dataPath: '.name' }) ]) // Check for error on .name
      );
    });

    test('should fail validation when age is wrong type', () => {
      const input = { userId: "u4", userName: "Invalid Age", userAge: "twenty", userStatus: 'active' }; // Wrong type for age
      const output = formatUserData(input);
      expect(validateUser(output)).toBe(false);
      expect(validateUser.errors).toEqual(
        expect.arrayContaining([ expect.objectContaining({ dataPath: '.age', keyword: 'type' }) ]) // Check for type error on .age
      );
    });

    // Add more invalid cases covering different schema violations...
  });

  // Test suite for edge cases
   describe('Edge Cases', () => {
     test('should produce valid JSON for input resulting in empty tags array', () => {
       const input = { userId: "u5", userName: "No Tags", userAge: 22, userStatus: 'active', userTags: '' };
       const output = formatUserData(input);
       expect(validateUser(output)).toBe(true);
       expect(validateUser.errors).toBeNull();
       expect(output.tags).toEqual([]); // Also check the formatter output itself
     });
     // Add more edge cases...
   });

});`}
          </pre>
        </div>
        <p>
          Within the invalid output tests, specifically checking the structure of the validation errors
          (e.g., using <code>expect.arrayContaining</code> and <code>expect.objectContaining</code>
          with properties like <code>dataPath</code>, <code>keyword</code>, <code>message</code>)
          is a robust way to ensure the validation is failing for the &lt;em&gt;correct&lt;/em&gt; reason.
        </p>


        <h2 className="text-2xl font-semibold mt-8 mb-4 flex items-center gap-2">
          <Check className="w-6 h-6 text-green-500" />
          Conclusion
        </h2>
        <p>
          Testing schema validation for your JSON formatter&apos;s output is a fundamental practice for building robust and reliable systems that handle structured data. By using a schema definition (like JSON Schema) and a validation library, and by writing comprehensive tests covering valid, invalid, and edge cases, you create a strong safety net. This practice minimizes bugs, ensures data integrity, upholds API contracts, and provides confidence during refactoring, ultimately leading to more stable and maintainable code.
        </p>
      </section>
    </div>
  );
}
