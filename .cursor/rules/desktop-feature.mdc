---
description: 
globs: 
alwaysApply: false
---
# Guide for Porting Features from Landing to Desktop App

## Architecture Overview
- `/landing` - Next.js web application with feature implementations
- `/desktop` - Electron desktop application, target for new features
- `/shared` - Common utilities used by both applications

## Implementation Flow

1. **Identify the Landing Page Implementation**
   - Source feature components are in: `/landing/app/tools/{feature-name}/`
   - Example: Base64 Encoder at `/landing/app/tools/base64-codec/Base64Codec.tsx`
   - Example: JSON Formatter at `/landing/app/tools/json-formatter/JsonFormatter.tsx`

2. **Locate Shared Logic**
   - Core business logic should be in: `/shared/src/{feature-name}/`
   - Example: Base64 functions at `/shared/src/base64-codec/index.ts`
   - Example: JSON utilities at `/shared/src/json-formatter/index.ts`
   - Import in desktop using: `import { ... } from 'shared/{feature-name}'`

3. **Create Desktop Component**
   - Target path: `/desktop/src/components/{feature-name}.tsx`
   - Use desktop UI components from: `/desktop/src/components/ui/`
   - Follow existing patterns like in `/desktop/src/components/json-formatter.tsx`
   - Adapt Next.js components to match desktop styling

4. **Update Desktop App**
   - Add to tools list in `/desktop/src/App.tsx`:
     ```tsx
     const tools: Tool[] = [
       // ... existing tools
       { id: '{feature-id}', name: '{Feature Name}', icon: <IconComponent size={16} /> },
     ]
     ```
   - Add conditional rendering in the same file:
     ```tsx
     {selectedTool === '{feature-id}' ? (
       <YourComponent className="min-h-full" />
     ) : (
       // ... existing code
     )}
     ```

5. **Testing Requirements**
      - Create a test file for each feature at `/desktop/test/{feature-name}.spec.ts`
      - Use shared test utilities from `/desktop/test/utils.ts`:
        ```tsx
        import { launchElectronWithRetry, findButtonByText } from './utils';
        ```
      - Find elements by text content instead of indices:
        ```tsx
        // Find and click feature button by text
        const featureButton = await findButtonByText(page, 'Feature Name');
        expect(featureButton).not.toBeNull();
        await featureButton.click();
        ```
      - Add proper waiting and error handling:
        ```tsx
        // Wait for component to load
        await page.waitForTimeout(1500);

        // Use try/catch with screenshots for better debugging
        try {
          // Test feature functionality
        } catch (error) {
          await page.screenshot({ path: path.join(__dirname, 'screenshots', 'failure.png') });
          throw error;
        }
        ```
      - Run tests with: `pnpm run test`
      - Test should verify feature renders correctly and operates as expected