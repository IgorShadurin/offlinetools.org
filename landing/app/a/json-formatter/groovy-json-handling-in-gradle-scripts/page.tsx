import type { Metadata } from "next";
import { FileJson, Code, Package, BookOpen, Lightbulb } from "lucide-react";

export const metadata: Metadata = {
  title: "Groovy JSON Handling in Gradle Scripts | Offline Tools",
  description:
    "Learn how to effectively parse, generate, and utilize JSON data within your Gradle build scripts using Groovy.",
};

export default function GroovyJsonHandlingArticle() {
  return (
    <>
      <h1 className="text-3xl font-bold mb-6 flex items-center">
        <FileJson className="w-8 h-8 mr-2 text-blue-600" />
        Groovy JSON Handling in Gradle Scripts
      </h1>

      <div className="space-y-6">
        <p>
          Gradle, a powerful and flexible build automation tool, uses Groovy or Kotlin DSL for writing build scripts.
          When working with complex build configurations, external data, or task inputs/outputs, you might encounter
          the need to handle JSON data directly within your <code>build.gradle</code> files. Groovy's excellent
          support for JSON makes this relatively straightforward.
        </p>

        <h2 className="text-2xl font-semibold mt-8 flex items-center">
          <BookOpen className="w-6 h-6 mr-2 text-green-600" />
          Why Handle JSON in Gradle?
        </h2>
        <p>
          There are several scenarios where processing JSON within your Gradle script can be beneficial:
        </p>
        <ul className="list-disc pl-6 space-y-2 my-4">
          <li>
            <strong>Configuration Management:</strong> Reading build settings, versions, or credentials from a JSON config file.
          </li>
          <li>
            <strong>Task Inputs/Outputs:</strong> Parsing a JSON report generated by another tool or generating a JSON file as a task output.
          </li>
          <li>
            <strong>External Data Integration:</strong> Processing data fetched from an external source or API (though typically this might happen in a separate script or plugin called by Gradle).
          </li>
          <li>
            <strong>Dynamic Task Configuration:</strong> Using data from a JSON structure to dynamically define tasks, dependencies, or properties.
          </li>
        </ul>

        <h2 className="text-2xl font-semibold mt-8 flex items-center">
          <Package className="w-6 h-6 mr-2 text-purple-600" />
          Groovy's Built-in JSON Capabilities
        </h2>
        <p>
          Groovy provides excellent support for JSON parsing and generation through the
          <code>groovy.json</code> package. The two main classes you'll interact with are:
        </p>
        <ul className="list-disc pl-6 space-y-2 my-4">
          <li>
            <strong><code>JsonSlurper</code>:</strong> For parsing JSON strings or streams into Groovy data structures (Lists, Maps, etc.).
          </li>
          <li>
            <strong><code>JsonOutput</code>:</strong> For generating JSON strings from Groovy data structures.
          </li>
        </ul>
        <p>
          These classes are usually available in the Gradle Groovy environment without needing explicit
          dependencies in your typical <code>build.gradle</code> file.
        </p>

        <h2 className="text-2xl font-semibold mt-8 flex items-center">
          <Code className="w-6 h-6 mr-2 text-orange-600" />
          Examples in Gradle Scripts
        </h2>

        <h3 className="text-xl font-semibold mt-6">1. Parsing JSON from a String</h3>
        <p>
          You can directly parse a JSON string defined within your script:
        </p>
        <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4 overflow-x-auto">
          <pre>
            {`import groovy.json.JsonSlurper

def jsonString = '''
{
  "name": "MyProject",
  "version": "1.0.0",
  "settings": {
    "buildDir": "dist",
    "minify": true
  },
  "tags": ["gradle", "json", "example"]
}
'''

def jsonSlurper = new JsonSlurper()
def config = jsonSlurper.parseText(jsonString)

println "Project Name: \${config.name}" // Access using dot notation
println "Project Version: \${config['version']}" // Access using map notation
println "Build Directory: \${config.settings.buildDir}"
println "First tag: \${config.tags[0]}"

// You can use this data later in your build configuration
gradle.ext.projectName = config.name
gradle.ext.projectVersion = config.version

task printConfig {
    doLast {
        println "Config from extension: \${gradle.ext.projectName} - \${gradle.ext.projectVersion}"
    }
}`}
          </pre>
        </div>
        <p>
          In this example, <code>JsonSlurper().parseText()</code> converts the JSON string into a Groovy object
          which behaves like nested Maps and Lists, allowing easy access using dot notation or map-style indexing.
        </p>

        <h3 className="text-xl font-semibold mt-6">2. Parsing JSON from a File</h3>
        <p>
          Reading configuration or data from an external JSON file is a common pattern. Let's assume you have a file
          named <code>config.json</code> in your project root:
        </p>
        <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4 overflow-x-auto">
          <pre>
            {`// Example config.json content:
// {
//   "apiUrl": "https://api.example.com/v1",
//   "timeout": 5000,
//   "features": {
//     "darkMode": false,
//     "analytics": true
//   }
// }

import groovy.json.JsonSlurper

def configFile = file('config.json')

if (configFile.exists()) {
    def jsonSlurper = new JsonSlurper()
    def projectConfig = jsonSlurper.parse(configFile) // Use parse() for files

    // Store config data in Gradle extensions for use across the build script
    gradle.ext.apiUrl = projectConfig.apiUrl
    gradle.ext.timeout = projectConfig.timeout
    gradle.ext.features = projectConfig.features

    task checkFeatures {
        doLast {
            if (gradle.ext.features.analytics) {
                println "Analytics feature is enabled."
            } else {
                println "Analytics feature is disabled."
            }
            println "API URL is: \${gradle.ext.apiUrl}"
        }
    }

} else {
    println "WARNING: config.json not found. Using default settings."
    // Define default settings if the file is missing
    gradle.ext.apiUrl = "http://localhost:8080"
    gradle.ext.timeout = 10000
    gradle.ext.features = [darkMode: false, analytics: false]
}`}
          </pre>
        </div>
        <p>
          Using <code>jsonSlurper.parse(file)</code> directly handles reading the file content and parsing it.
          It's good practice to check if the file exists before attempting to parse it.
        </p>

        <h3 className="text-xl font-semibold mt-6">3. Generating JSON Output</h3>
        <p>
          You might need to generate a JSON file as part of a build task, for example, a report or a configuration file for another tool.
        </p>
        <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4 overflow-x-auto">
          <pre>
            {`import groovy.json.JsonOutput

task generateBuildInfoJson {
    def buildInfoFile = layout.buildDirectory.file('reports/buildInfo.json').get().asFile

    outputs.file buildInfoFile // Declare the output file

    doLast {
        def buildInfo = [
            projectName: rootProject.name,
            version: version, // Project version
            buildTime: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
            gradleVersion: gradle.gradleVersion,
            javaVersion: System.getProperty('java.version')
        ]

        // Convert Groovy map to JSON string
        def jsonOutputString = JsonOutput.toJson(buildInfo)

        // Optional: make the output pretty-printed
        def prettyJsonOutputString = JsonOutput.prettyPrint(jsonOutputString)

        // Ensure parent directories exist
        buildInfoFile.getParentFile().mkdirs()

        // Write JSON string to file
        buildInfoFile.text = prettyJsonOutputString

        println "Generated build info file: \${buildInfoFile.getAbsolutePath()}"
    }
}`}
          </pre>
        </div>
        <p>
          Here, we create a Groovy Map containing the build information. <code>JsonOutput.toJson()</code> converts
          this Map into a JSON string. <code>JsonOutput.prettyPrint()</code> improves readability. The task declares
          its output file using <code>outputs.file</code>, which helps Gradle with task up-to-date checks.
        </p>

        <h3 className="text-xl font-semibold mt-6">4. Using JSON Data in Task Configuration</h3>
        <p>
          JSON data can dynamically influence how tasks behave.
        </p>
        <div className="bg-gray-100 p-4 rounded-lg dark:bg-gray-800 my-4 overflow-x-auto">
          <pre>
            {`import groovy.json.JsonSlurper

// Assume features.json exists with content like:
// {
//   "enabledFeatures": ["auth", "payment"],
//   "disabledFeatures": ["admin"]
// }

def featuresFile = file('features.json')
def featureConfig = [enabledFeatures: [], disabledFeatures: []] // Default

if (featuresFile.exists()) {
    try {
        featureConfig = new JsonSlurper().parse(featuresFile)
    } catch (Exception e) {
        println "WARNING: Failed to parse features.json: \${e.message}"
        // Use default config on error
    }
} else {
     println "WARNING: features.json not found. Using default features."
}

// Example: Configure a Copy task based on enabled features
task copyFeatureFiles(type: Copy) {
    from 'src/main/resources/features'
    into layout.buildDirectory.dir('features')

    // Include files only if the feature is enabled
    include { FileTreeElement details ->
        def fileName = details.name
        // Assuming file names are like 'auth.feature', 'payment.feature', 'admin.feature'
        def featureName = fileName.tokenize('.')[0]
        return featureConfig.enabledFeatures.contains(featureName)
    }
}

// Example: Configure a task property based on JSON
gradle.ext.featureToggles = featureConfig.enabledFeatures.collectEntries { [(it): true] } +
                           featureConfig.disabledFeatures.collectEntries { [(it): false] }

task showFeatureToggles {
    doLast {
        println "Current Feature Toggles: \${gradle.ext.featureToggles}"
    }
}`}
          </pre>
        </div>
        <p>
          Here, the <code>copyFeatureFiles</code> task dynamically determines which files to include based on the
          content of <code>features.json</code> parsed during the configuration phase. We also create a map of
          feature toggles stored in <code>gradle.ext</code>, which can be used by other tasks or plugins.
        </p>

        <h2 className="text-2xl font-semibold mt-8 flex items-center">
          <Lightbulb className="w-6 h-6 mr-2 text-yellow-600" />
          Tips and Considerations
        </h2>
        <ul className="list-disc pl-6 space-y-2 my-4">
          <li>
            <strong>Configuration vs. Execution Phase:</strong> Most JSON parsing (especially for configuration) happens during Gradle's configuration phase (when the script is evaluated). If JSON processing depends on task outputs or needs to happen during task execution, wrap the logic inside <code>doLast {}</code> or <code>doFirst {}</code> blocks. Accessing files or performing actions that change state should generally be done in execution phase blocks.
          </li>
          <li>
            <strong>Error Handling:</strong> Always consider what happens if the JSON file doesn't exist or is malformed. Use <code>try-catch</code> blocks for robustness, especially when parsing external files. Provide default values or informative warnings.
          </li>
          <li>
            <strong>Large JSON Data:</strong> For very large JSON files, parsing them entirely into memory during the configuration phase might impact build performance. Consider processing them within a task's <code>doLast</code> block or using streaming parsers if necessary (though <code>JsonSlurper</code> is generally efficient for typical config sizes).
          </li>
          <li>
            <strong>Dependencies:</strong> The <code>groovy.json</code> package is typically part of the Groovy distribution bundled with Gradle. You usually don't need to add extra dependencies for basic JSON handling.
          </li>
          <li>
            <strong>Kotlin DSL:</strong> If you are using Kotlin DSL (<code>build.gradle.kts</code>), you would use libraries like Jackson or kotlinx.serialization for JSON handling, as Groovy's built-in capabilities are not directly available in the Kotlin environment.
          </li>
          <li>
            <strong>File Paths:</strong> Use Gradle's built-in methods like <code>file('path/to/file.json')</code> or <code>layout.projectDirectory.file('path/to/file.json').get().asFile</code> for reliable path handling.
          </li>
        </ul>

        <h2 className="text-2xl font-semibold mt-8">Conclusion</h2>
        <p>
          Groovy provides powerful and convenient ways to handle JSON data directly within your Gradle build scripts. Whether you need to read configuration, process task inputs, or generate outputs, <code>JsonSlurper</code> and <code>JsonOutput</code> offer simple and effective solutions. By leveraging these capabilities, you can create more dynamic, data-driven, and flexible build processes. Remember to consider the phase of execution (configuration vs. execution) and implement robust error handling for reliable scripts.
        </p>
      </div>
    </>
  );
}