---
description: 
globs: 
alwaysApply: false
---
# Shared Feature Development Guidelines

This document provides a step-by-step guide for implementing new shared features in the offlinetools project. Each shared feature should be implemented in the shared library first, then exposed through a dedicated page in the landing site.

## Step 0: Research Before Implementation using MCP or Browse abilities

Before beginning development, conduct thorough research to understand industry standards, best practices, and user expectations:

1. **Competitive Analysis**: Visit at least 10 websites/tools with similar functionality to:
   - Identify common features and options that users expect
   - Note UI/UX patterns and conventions specific to this type of tool
   - Analyze which options are considered essential vs nice-to-have
   - Determine common edge cases and error handling approaches
   - Observe performance optimizations for larger inputs/files

2. **Document Findings**: Create a brief summary of research findings, including:
   - Core features that must be implemented
   - Optional features that could be added in future iterations
   - UI/UX best practices specific to this tool type
   - Potential challenges and how other implementations address them

3. **Set Scope**: Based on research, define a clear scope for the initial implementation that:
   - Focuses on the must-have features
   - Follows established conventions for similar tools
   - Considers extensibility for future enhancements

This research phase helps ensure the feature meets user expectations and follows established patterns, leading to a more intuitive and complete implementation.

## Step 1: Implement the Core Feature in Shared Library

Create a new feature directory under `shared/src/feature-name/` with implementation:

```
shared/src/
└── feature-name/
    ├── index.ts         # Main implementation with exported functions/types
    └── index.test.ts    # Tests for the feature
```

Example paths:
- `shared/src/json-validator/index.ts`
- `shared/src/json-validator/index.test.ts`

### Implementation Guidelines:

1. Use TypeScript for all implementations
2. Include JSDoc comments for all exports (functions, interfaces, enums)
3. Export all types and enums needed by the landing page
4. For error handling, throw descriptive Error objects 
5. Structure the code with a clear public API

Example implementation pattern:

```typescript
/**
 * Options for the feature
 */
export interface FeatureOptions {
  // Define options here
}

/**
 * Default options for the feature
 */
export const DEFAULT_OPTIONS: FeatureOptions = {
  // Default values
};

/**
 * Main function for the feature
 * @param input - The input to process
 * @param options - Optional configuration
 * @returns The processed output
 * @throws Error if processing fails
 */
export function featureFunction(input: string, options = DEFAULT_OPTIONS): string {
  // Implementation
}
```

## Step 2: Test the Feature Implementation

Create comprehensive tests in `index.test.ts` to cover:

1. Basic functionality
2. Edge cases
3. Error handling
4. All options/configurations

### Test Framework

Unless otherwise specified, use Jest as the testing framework for the shared library. The project is already configured with Jest, and test files should follow Jest's conventions and assertions.

Example test structure:

```typescript
import { featureFunction, FeatureOptions } from './index';

describe('featureFunction', () => {
  // Test with valid inputs
  it('should correctly process valid input', () => {
    const result = featureFunction('valid input');
    expect(result).toBe('expected output');
  });

  // Test with different options
  it('should respect provided options', () => {
    const options: FeatureOptions = { /* custom options */ };
    const result = featureFunction('input', options);
    expect(result).toBe('expected output with options');
  });

  // Test error handling
  it('should throw an error for invalid input', () => {
    expect(() => {
      featureFunction('invalid input');
    }).toThrow('Expected error message');
  });
});
```

Run tests using: `cd shared && pnpm test`

## Step 3: Export the Feature from Shared

Add the export to `shared/src/index.ts`:

```typescript
// Existing exports...

// Export new feature
export * from './feature-name';
```

## Step 4: Create a Tool Page in Landing Site

Create a new page for the tool at `landing/app/tools/feature-name/page.tsx`:

1. Use a client-side rendered component with the "use client" directive
2. Import the feature functions from "shared" package
3. Implement a user interface with appropriate controls and displays
4. Ensure mobile responsiveness with responsive classes

Example page structure:

```tsx
"use client"

import { Container } from "@/components/ui/container"
import { SectionHeading } from "@/components/ui/section"
import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
// Import other UI components as needed
import { featureFunction, FeatureOptions } from "shared"
import { useState } from "react"
// Import icons as needed

export default function FeatureNamePage() {
  // State management
  const [input, setInput] = useState("")
  const [output, setOutput] = useState("")
  const [error, setError] = useState<string | null>(null)
  
  // Handle processing
  const handleProcess = () => {
    try {
      const result = featureFunction(input)
      setOutput(result)
      setError(null)
    } catch (error) {
      setError((error as Error).message)
      setOutput("")
    }
  }
  
  return (
    <>
      <Container className="py-8 md:py-12">
        <SectionHeading
          title="Feature Name"
          description="Description of what this tool does and how it helps users."
        />
        
        {/* UI Implementation */}
        {/* Follow the pattern of existing tools like JSON Formatter */}
        {/* Ensure responsiveness with mobile-first classes */}
      </Container>
    </>
  )
}
```

Example path: `landing/app/tools/json-validator/page.tsx`

## Step 5: Add the Tool to Online Tools List

Add the new tool to the list in `landing/components/online-tools-grid.tsx`. Make sure to include the title, path, and a concise description that explains what the tool does:

```typescript
export const onlineTools = [
  // Existing tools...
  {
    title: "Feature Name",     // User-friendly name
    path: "/tools/feature-name", // URL path to the tool page
    description: "Clear, concise description of what this tool does and what problem it solves for users."
  },
  // Rest of tools...
]
```

### Guidelines for Tool Descriptions:

1. **Be concise**: Keep descriptions under 100 characters when possible
2. **Focus on value**: Explain what the tool helps users accomplish
3. **Use action verbs**: Start with verbs like "Convert", "Format", "Validate", etc.
4. **Be specific**: Mention key features or options that make the tool valuable
5. **Maintain consistency**: Follow the pattern of existing tool descriptions

Examples of good descriptions:
- "Format and beautify your JSON with customizable indentation options."
- "Convert text to Base64 or decode Base64 to plaintext with URL-safe option."
- "Validate XML against schemas and highlight errors with detailed reports."

The same description should be used in two places:
1. In the `onlineTools` array in `landing/components/online-tools-grid.tsx`
2. In the `SectionHeading` component of your tool's page

## Step 6: Link Related Tools

For each new tool, implement related tool links to enhance navigation and discoverability. Add a "Related tool" component below the SectionHeading that links to 1-2 functionally similar or complementary tools. Use the standardized UI pattern with the LinkIcon from lucide-react and Next.js Link component. Always maintain bi-directional linking - if Tool A links to Tool B, ensure Tool B also links back to Tool A. This cross-linking creates a connected ecosystem that improves user experience, reduces navigation friction, and increases tool usage by helping users discover related functionality they might otherwise miss.

## Final Checks

After completing all steps:

1. Run linting and type checking: `cd landing && pnpm lint && pnpm types:check`
2. Ensure mobile responsiveness of the UI
3. Test the feature with various inputs
4. Verify proper error handling and display

Remember to follow the general project rules:
- Use pnpm for dependency management
- Develop components to be mobile-friendly
- Use TypeScript for strong typing
- Add comprehensive JSDoc comments
- Keep files under 400 lines (split if needed)
- Reuse UI components when possible 